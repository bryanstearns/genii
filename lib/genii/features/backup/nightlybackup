#!/usr/bin/env ruby
#
# Make a nightly backup, based on individual configuration files of things
# to be backed up or archived, eg:
# - database backups
# - system, apache, mail, rails logs
# - RRD databases
# - wiki content
# - hudson build history & stats
#
# each contribution is
# - (by default) tarred
# - (by default) encrypted
# - (optionally) copied to a date-stamped S3 bucket
# - (optionally) rotated, with...
# - (optional) .. flushing to keep a recent set of a given size
#
# Each thing is defined in a file in the configuration directory; it's either:
# - a .yml file containing a hash with these attributes (which are used as the
# options to initialize a generic BackupItem):
#
# - or a .rb file containing a BackupItem subclass that can be initialized without
# extra options.
#
# On S3, we keep
# - per-item per-host backup buckets named eg "paydici_live.cyan.paydici.com"
# - per-item per-host archive buckets named eg "syslog.cyan.paydici.com"

require 'fileutils'
require 'yaml'
require 'syslog'
require 'optparse'
require 'rubygems'
require 's3'
require 'ruby-debug'

def log(msg)
  if STDOUT.isatty
    puts msg
  else
    Syslog.open('nightlybackup', Syslog::LOG_PID | Syslog::LOG_CONS) \
      unless Syslog.opened?
    Syslog.log(Syslog::LOG_INFO, msg)
  end
end

def die(msg)
  log(msg)
  exit(1)
end

class String
  def classify
    # Fake ActiveSupport's classify:
    # murky_soup --> MurkySoup
    self.downcase.split('_').map do |word|
      word[0..0].upcase + word[1..-1]
    end.join
  end

  def constantize
    # Fake ActiveSupport's constantize
    names = self.split('::')
    constant = Object
    names.each do |name|
      constant = constant.const_defined?(name) ? constant.const_get(name) : constant.const_missing(name)
    end
    constant
  end
end

module Execute
  def execute(command)
    # Run a shell command in a subprocess and return its standard output
    output = IO.popen("(#{command}) 2>&1") do |f|
      if block_given?
        yield f
        f.close_write
      end
      f.read
    end
  end
end

class BackupItem
  # One thing to be backed up.
  include Execute
  attr_accessor :name

  def initialize(context, options)
    @context = context
    options.each {|k, v| send("#{k}=", v) }
  end

  def run
    # A subclass will likely override this and not call super
    puts "Running #{inspect}"
  end

  def pathname(extension=nil)
    File.join(@context.latest_dir, "#{name}#{extension}")
  end

  def copy_to_s3
    old = "#{name}.old"
    oldest = "#{name}.oldest"
    # If oldest exists, remove it.
    # if old exists, rename it to oldest
    # if it exists, rename it to old
    # copy it up
  end
end

class NightlyBackup
  include Execute

  # Values we load from our configuration file
  attr_accessor :hostname, :domain, 
                :s3_access_key_id, :s3_secret_access_key,
                :encryption_key_path, :backup_dir, :verbose

  # Other values
  attr_accessor :items, :configuration_root

  def initialize(*args)
    @configuration_root ||= "/etc/nightlybackup"
    @backup_dir ||= "/var/spool/backup_snapshots"
    parse_options(args)

    read_configuration
    load_plugins
    read_configured_items
  end

  def parse_options(args)
    OptionParser.new do |opts|
      opts.banner = """nightlybackup - do nightly backup processing

Usage: nightlybackup [options]
"""

      opts.on("--config FILE", "Use configuration from here, instead of #{@configuration_root}")\
        {|@configuration_root|}
      opts.on("--backup_dir NAME", "Backup to a hierarchy rooted here (instead of #{@backup_dir})")\
        {|@backup_dir|}
      opts.on("--force", "Overwrite today's backup if it exists already")\
        {|@force|}
      opts.on("-v", "--verbose", "Blah blah blah")\
        {|@verbose|}
      opts.on_tail("-h", "--help", "Show this message") do
        puts opts
        return 2
      end
    end.parse!(args)
  end

  def read_configuration
    configuration = load_yaml(configuration_file)
    configuration.each {|k, v| puts "#{k} < #{v}"; send("#{k}=", v) }
  end

  def load_plugins
    $LOAD_PATH << plugin_dir \
      unless $LOAD_PATH.include?(plugin_dir)
    Dir.glob("#{plugin_dir}/*.rb") do |path|
      name = File.basename(path, ".rb")
      log("requiring plugin #{name}")
      require name
    end
  end

  def read_configured_items
    @items = []
    $LOAD_PATH << configuration_dir \
      unless $LOAD_PATH.include?(configuration_dir)
    Dir.glob("#{configuration_dir}/*") do |path|
      name, extension = /([^\/]+)\.([^\.]+)$/.match(path)[1,2]
      item = case extension
      when "rb"
        log("requiring #{name}")
        require name
        name.classify.constantize.new(self)
      when "yml"
        log("reading #{path}")
        options = load_yaml(path)
        options["name"] ||= name
        klass = options.delete("class")
        klass = klass ? klass.classify.constantize : BackupItem
        klass.new(self, options)
      end
      @items << item
    end
  end

  def run!
    if items.empty?
      log "nothing to do!"
      exit(0)
    end

    create_latest_folder
    backup_items
    0
  end

  def create_latest_folder
    log("making latest dir: #{latest_dir}")
    if File.directory?(latest_dir)
      die("Today's backup already exists: #{latest_dir}") \
        unless @force
      FileUtils.rm_rf(latest_dir)
    end
    FileUtils.mkdir_p(latest_dir)
  end

  def backup_items
    @items.each {|item| item.run }
  end

  def purge_old
    # Clean up old backups
    # - Keep all from the last two weeks
    # - Keep all Mondays less than two months old
    # - Keep all second Mondays of the month (used to be first Monday, but this
    #   increases the chance that we'll get most of the month's rental action)
    # - Keep everything until we've got backups from the most recent two weeks.
    doomed = []
    recent_count = 0
    Dir.entries(backup_dir).sort.each do |f|
      next unless f =~ /(\d\d)(\d\d)(\d\d)(\S\S\S)$/
      ignored, year, month, day, day_of_week = $~.to_a
      timestamp = Time.local(year.to_i, month.to_i, day.to_i, 0, 0, 0, 0)
      days_old = (Time.now - timestamp) / 86400
      if days_old <= 14
        log "-- Keeping #{f}: less than two weeks old."
        recent_count += 1
        next
      end
      if day_of_week == 'Mon'
        if days_old <= 62
          log "-- Keeping #{f}: a Monday less than about two months old."
          next
        end
        if [8..15].include? day
          log "-- Keeping #{f}: a second Monday of the month."
          next
        end
      end
      log "-- Deleting #{f}"
      doomed << f
    end

    if recent_count < 14
      log "-- .. postponing cleanup: recent backup count is #{recent_count}"
    else
      doomed.map {|f| FileUtils.rm("#{backup_dir}/#{f}") }
    end
  end

  def today
    Time.now.strftime("%y%m%d%a") # "090817Mon"
  end

  def latest_dir
    "#{backup_dir}/#{today}"
  end


  def plugin_dir
    "#{configuration_root}/plugin.d"
  end

  def configuration_dir
    "#{configuration_root}/conf.d"
  end

  def configuration_file
    "#{configuration_root}/nightlybackup.yml"
  end

  def load_yaml(path)
    log("loading configuration #{path}")
    result = File.open(path) {|f| YAML::load(f) }
    result = {} if result == false # the file is empty?!
    result
  end

  def encrypt_command(options={})
    cmd = [ "/usr/local/bin/encdec --key #{encryption_key_path}" ]
    cmd << "--in #{options[:in]}" if options[:in]
    cmd << "--out #{options[:out]}" if options[:out]
    cmd.join(' ')
  end

  def database_dump_command(database, user, password)
    password_option = " -p#{@password}" if password
    "mysqldump --single-transaction --database #{database} " +
      "-u#{user}#{password_option} --opt --skip-extended-insert"
  end

  def s3
    @s3 ||= S3::Service.new(:access_key_id => s3_access_key_id,
                            :secret_access_key => s3_secret_access_key,
                            :use_ssl => true) #, :debug => true)
  end

  def hostname
    @hostname ||= `hostname --fqdn`.strip
  end

  def s3_bucket_name_expansion(name)
    "#{name}.backup.#{hostname}"
  end

  def s3_bucket(bucket_name, options=nil)
    options ||= {}
    bucket_name = s3_bucket_name_expansion(bucket_name)
    @s3_buckets ||= {}
    bucket = @s3_buckets[bucket_name]
    unless bucket
      bucket = begin
        s3.buckets.find(bucket_name)
      rescue S3::Error::NoSuchBucket
        nil
      end
      if !bucket
        return nil unless options[:create]
        bucket = @s3.buckets.build(bucket_name)
        bucket.save(:us)
      end
      @s3_buckets[bucket_name] = bucket
    end
    bucket
  end

  def s3_bucket_contains?(bucket_name, name)
    bucket = s3_bucket(bucket_name)
    bucket && bucket.objects.find_first(name) 
  rescue S3::Error::NoSuchKey
    nil
  end

  def s3_bucket_add(bucket_name, name, content_path, options=nil)
    return nil if options[:unless_exists] && s3_bucket_contains?(bucket_name, name)
    options ||= {}
    bucket = s3_bucket(bucket_name, options.merge(:create => true))
    object = bucket.objects.build(name)
    File.open(content_path) do |f|
      object.content = f
      object.save
    end
    object
  end
end

exit NightlyBackup.new(*ARGV).run!
